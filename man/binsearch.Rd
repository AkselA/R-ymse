% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/binary search.R
\name{binsearch}
\alias{binsearch}
\alias{binclosest}
\title{Binary search}
\usage{
binsearch(val, arr, L = 1L, H = length(arr))

binclosest(val, arr, L = 1L, H = length(arr))
}
\arguments{
\item{val}{the value to search for}

\item{arr}{a sorted array to make the search in}

\item{L}{a lower bound}

\item{H}{an upper bound}
}
\value{
A single integer representing an index on the input array.
}
\description{
Find the position of a given value in a sorted array
}
\details{
While both \code{val} and \code{arr} can be either integer or double, the
algorithm is limited by integer storage in how long the array can be.
\code{L} and \code{H} can be used to limit the range of indices to be search within. \cr
\code{binsearch} will return either the index of the exact match, or the index just below
if no exact match is found. This means that if \code{val} is less than the lowest value
in \code{arr} (and \code{L=1}), a \code{0} will be returned, which can lead to issues as
such an index does not exist in R. An array indexed by \code{0} will return a zero 
length object.
\code{binclosest} will return the index of the closest match, and therefore a \code{1} 
in the situation where \code{binsearch} returns a \code{0}. If there is a tie the lower
index will be returned. \cr
In either case, if there are duplicate matches, the lower index will be returned.
}
\examples{
binsearch(15, (1:9)*3.333)
binsearch(2, (1:9)*3.333)
binclosest(2, (1:9)*3.333)

binsearch(18, seq_len(2e9))
\dontrun{
binsearch(18, seq_len(3e9))}
binsearch(18, seq_len(3e9), H=2e9)
binsearch(2000, seq_len(3e7)*100 + 0.1)

set.seed(1)
x <- sort(sample(1:300, 30))
r <- sort(sample(1:300, 30))

plot(sapply(r, binsearch, x), type="l")
lines(sapply(r, binclosest, x), col="red")

x <- c(1, 2, 3, 5, 8, 9)
binclosest(6, x)
binclosest(7, x)
binclosest(5, x)
}
